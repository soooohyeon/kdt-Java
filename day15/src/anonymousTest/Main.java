package anonymousTest;
//4. 익명클래스 - 출력
public interface Main {
	public static void main(String[] args) {
		ClassA ca = new ClassA();
		
//		InterA ia = new ClassA();	// 업캐스팅 - 해당 방법으로 객체화 생성 가능
//		InterA ia = new InterA();	// 불가능 - 인터페이스는 추상메소드때문에 불가
//		Cannot instantiate the type InterA
//		구현되지 않은 (미완성된) 메소드가 있기 때문에 객체 생성 불가능
//		구현되지 않은 것을 구현해주면 객체 생성 가능하게됨
		
		InterA ia = new InterA() {

			@Override
			public void printData() {
				System.out.println("익명클래스에서 메소드 오버라이딩");
			}
			
		};
		
		System.out.println(ia);	// $ 내부클래스라는 뜻, $뒤 숫자는 익명클래스를 지칭
//		하지만 이름이 없는 익명클래스이기 때문에 숫자로 출력되며 익명클래스의 개수가 늘어날수록 숫자도 늘어나게됨
//		또 메인 메소드가 실행되야만 실행 가능한 클래스이기 때문에 '로컬 내부 클래스'
		
		ia.printData();	// 익명클래스 내부에 오버라이딩된 메소드 호출
		
//		부모타입에 자식타입의 생성자(참조값)가 들어감 = 업캐스팅
		
//		인터페이스	: 추상메소드를 가지고 있는 부모
//		클래스	: 인터페이스의 추상메소드를 구현(오버라이딩)하는 자식
//		** 오버라이딩은 상속관계에서만 가능
//		즉, 인터페이스 InterA가 부모고 익명클래스가 자식이 되며 부모에 자식을 담은 것 이므로 Up Casting
		
		
//		[강사님 정리]
//		InterA는 인터페이스 : 부모(상위 타입)
//		인터페이스를 구현한 클래스는 모두 InterA를 부모로 둔다.
//		인터페이스는 객체를 생성할 수 없어서 익명클래스를 통해 인터페이스의 메소드를 구현하고 객체로 생성할 수 있다.
//		
//		익명클래스 : 자식(하위 타입)
//		익명클래스는 InterA 인터페이스를 자동으로 implements한다
//		익명클래스는 작성된 시점에 생성된 하나의 구체적인 클래스로 동작한다
//		이 클래스는 인터페이스의 메소드를 반드시 구현해야한다
//		
//		업캐스팅
//		익명클래스의 인스턴스는 인터페이스 InterA 타입의 변수에 저장된다. (업캐스팅)
//		즉, 자식클래스 타입(익명클래스)을 부모클래스(InterA)의 참조변수 ia에 저장한 상태이다.
//		
//		ia 참조변수
//		타입이 InterA, 익명클래스 객체는 인터페이스 타입의 참조변수에 저장된다.
//		부모타입으로 참조하고 있지만 실제 메소드 호출시에는 오버라이딩된 자식 메소드가 실행된다.(다형성)
		
	}
}
